# ================== preambles ==================
# file_server: 'hostPath', 'emptyDir', or NFS server address
# alias: localhost == hostPath, temp == temporary == emptyDir
{% macro volume_block() %}
volumes:
{% for git_repo in GIT_REPOS %}
- name: {{ git_repo | to_hyphen }}
  gitRepo:
    repository: https://{{GIT_USER}}:{{GIT_TOKEN}}@github.com/stanfordvl/{{git_repo}}
    revision: {{ GIT_SNAPSHOT_BRANCH }}
{% endfor %}
- name: fs
{% if FS_TYPE == 'emptyDir' %}
  emptyDir: {}
{% elif FS_TYPE == 'hostPath' %}
  hostPath:
    path: {{ FS_PATH_ON_SERVER }}
{% elif FS_TYPE == 'nfs' %}
  nfs:
    server: {{ FS_SERVER }}
    path: {{ FS_PATH_ON_SERVER }}
{% else %}
  {{ raise("unknown fs type, please check ~/.surreal.yml:fs.type") }}
{% endif %}
{% endmacro %}

# containers:
{% macro container_block(type, name, image, args, resource_request, resource_limit) %}
- name: {{ name }}
  image: {{ image }}
  imagePullPolicy: Always
  env:
  {% for git_repo in GIT_REPOS %}
  - name: repo_{{git_repo | to_underscore}}
    # Note that the path is duplicated because gitVolume doesn't allow the
    # same mount path, but the git repos are cloned as a subdir.
    value: /mylibs/{{git_repo}}/{{git_repo}}
  {% endfor %}
  - name: mujoco_key_text
    value: {{ MUJOCO_KEY_TEXT }}
  - name: my_node_name
    valueFrom:
      fieldRef:
        fieldPath: spec.nodeName
  - name: my_pod_name
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  - name: my_pod_namespace
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace
  - name: my_pod_ip
    valueFrom:
      fieldRef:
        fieldPath: status.podIP
  {% if type == 'learner' %}
  - name: DISABLE_MUJOCO_RENDERING
    value: "1"
  {% endif %}
  volumeMounts:
  # WARNING: will be mounted to /mylibs/surreal/surreal
  {% for git_repo in GIT_REPOS %}
  - name: {{ git_repo | to_hyphen }}
    mountPath: /mylibs/{{ git_repo }}
  {% endfor %}
  - name: fs
    mountPath: {{ FS_MOUNT_PATH }}
  args: {{ args }}
  {% if resource_request | length > 0 or resource_limit | length > 0 and type in ['agent', 'learner']%}
  resources:
    {% if resource_request | length > 0 and type in ['agent', 'eval', 'learner']%}
    requests:
      {% for req_key, req_val in resource_request.items() %}
      {{req_key}}: {{req_val}}
      {% endfor %}
    {% endif %}
    {% if resource_limit | length > 0 and type in ['agent', 'learner']%}
    limits:
      {% for lim_key, lim_val in resource_limit.items() %}
      {{lim_key}}: {{lim_val}}
      {% endfor %}
    {% endif %}
  {% endif %}
{% endmacro %}

# node tainting to avoid system pods being scheduled to experiment nodes in autoscaling
{% set tolerations_block %}
tolerations:
- key: "surreal"
  operator: "Exists"
  effect: "NoExecute"
- key: "node.alpha.kubernetes.io/notready"
  operator: "Exists"
  effect: "NoExecute"
  tolerationSeconds: 3600
{% endset %}

# ================== headless service provides DNS ==================
---
apiVersion: v1
kind: Service
metadata:
  name: surreal
spec:
  selector:
    type: nonagent
  clusterIP: None
  ports:
  - port: 1  # doesn't matter what you put here, enables all ports

---
# Cloud provider will assign an external IP, find it by looking for `tensorboard`:
# kubectl get svc -o wide
kind: Service
apiVersion: v1
metadata:
  name: tensorboard
spec:
  # magic line here. Only works on cloud providers
  type: LoadBalancer
  selector:
    type: nonagent
  ports:
  - name: tensorboard
    protocol: TCP
    # port: where external request should go to
    port: 6006
    # targetPort is where the container listens internally
    targetPort: 6006

# ================== nonagents, all on one pod ==================
---
apiVersion: v1
kind: Pod
metadata:
  name: nonagent
  labels:
    type: nonagent
spec:
  hostNetwork: true
  dnsPolicy: ClusterFirstWithHostNet
  hostname: {{ NONAGENT_HOST_NAME }}
  subdomain: surreal
  {{ volume_block() | indent(2) }}
  {{ tolerations_block | indent(2) }}

{% if NONAGENT_SELECTOR | length > 0 %}
  nodeSelector:
    {% for selector_key, selector_val in NONAGENT_SELECTOR.items() %}
    {{selector_key}}: {{selector_val}}
    {% endfor %}
{% endif %}
  containers:
{% for ENTITY in ['ps', 'learner', 'replay',
                  'tensorboard', 'tensorplex', 'loggerplex'] %}
  {{ container_block(ENTITY,ENTITY,
    NONAGENT_IMAGE,
    ["--cmd", CMD_DICT[ENTITY]],
    NONAGENT_RESOURCE_REQUEST,
    NONAGENT_RESOURCE_LIMIT)
    | indent(2) }}
{% endfor %}

# ================== agents, each on separate pod ==================
{% for N in range(CMD_DICT.agent | length) %}
---
apiVersion: v1
kind: Pod
metadata:
  name: agent-{{N}}
  labels:
    type: agent
spec:
  hostNetwork: false
  hostname: agent-{{N}}
  subdomain: surreal
  restartPolicy: Never
  {{ volume_block() | indent(2) }}
  {{ tolerations_block | indent(2) }}
{% if AGENT_SELECTOR | length > 0 %}
  nodeSelector:
    {% for selector_key, selector_val in AGENT_SELECTOR.items() %}
    {{selector_key}}: {{selector_val}}
    {% endfor %}
{% endif %}
  containers:
  {{ container_block('agent', 
    'agent-' + (N|string),
    AGENT_IMAGE,
    ["--cmd", CMD_DICT.agent[N]],
    AGENT_RESOURCE_REQUEST,
    AGENT_RESOURCE_LIMIT)
    | indent(2) }}
{% endfor %}

# ================== evals, each on separate pod ==================
{% for N in range(CMD_DICT.eval | length) %}
---
apiVersion: v1
kind: Pod
metadata:
  name: eval-{{N}}
  labels:
    type: eval
spec:
  hostNetwork: false
  hostname: eval-{{N}}
  subdomain: surreal
  restartPolicy: Never
  {{ volume_block() | indent(2) }}
  {{ tolerations_block | indent(2) }}
{% if AGENT_SELECTOR | length > 0 %}
  nodeSelector:
    {% for selector_key, selector_val in AGENT_SELECTOR.items() %}
    {{selector_key}}: {{selector_val}}
    {% endfor %}
{% endif %}
  containers:
  {{ container_block('eval', 
    'eval-' + (N|string),
    AGENT_IMAGE,
    ["--cmd", CMD_DICT.eval[N]],
    AGENT_RESOURCE_REQUEST,
    AGENT_RESOURCE_LIMIT)
    | indent(2) }}
{% endfor %}
